-> Process can request, use and release resources
-> resources are partitioned into instances

-> 4 conditions of deadlock: 
1. Mutual Exclusion 2. Hold and Wait 3. No preemption 4. Circular Wait
-> request and asssignment edge in a resource-allocation graph
-> 3 ways to deal with deadlock problem
  1. Deadlock avoidance = stay in a safe state
  2. Deadlock prevention => ensure that at-least one condition is not met
  3. Enter, detect and recover from a deadlock
  
!! Deadlock Prevention = restrain the way requests are made
1. Mutual Exclusion = can't deny this property
2. Hold and Wait = request and be allocated all resources before execution
3. No preemption = release all resources if it needs an unavailable resource
4. Circular Wait = ordering of resource types

!! Deadlock Avoidance

!! Resource Allocation graph

!! Safe, unsafe state

Single instance of a resource type -> resource-allocation graph
Multiple instances of a resource type -> Banker's algorithm

Banker's algorithm
-> algo for deadlock avoidance
-> multiple instances


!! Safety Algorithm

!! Deadlock detection
-> detection algorithm
-> recovery scheme
